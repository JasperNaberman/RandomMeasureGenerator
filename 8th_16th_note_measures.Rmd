---
title: "`r substring(gsub('-', ' ', strsplit(getwd(), '/')[[1]][6]), 8)`"
subtitle: ""
author: "`r strsplit(getwd(), '/')[[1]][3]`"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    fig_caption: false
    toc: true
    number_sections: true
editor_options: 
  chunk_output_type: console
---


```{r setup-chunk, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = FALSE, cache.lazy = FALSE, message = FALSE,
                      warning = FALSE, fig.width = 12, fig.align = "center", fig.pos = "H",
                      tidy = TRUE, tidy.opts = list(width.cutoff = 68))

options(tinytex.verbose = TRUE)
```


```{r initialization-chunk}
packageList  <- c("futurewhiz.common.code", "future.viz", "squla.experiments", "squla.content",
                  "beepr", "cowplot", "chron", "data.table", "devtools", "directlabels", "ggplot2", "gridExtra", "ISOweek", "kableExtra",
                  "knitr", "lubridate", "parallel", "pracma", "RColorBrewer", "scales", "stringi", "stringr", "timechange", "tools", "zoo",
                  "magick", "shiny")

newPackages <- packageList[!(packageList %in% installed.packages()[, "Package"])]

if (length(newPackages)) {
  install.packages(newPackages)
}

invisible(lapply(packageList, library, character.only = TRUE))

OVERWRITE_TABLES <- FALSE
MC_CORES <- detectCores() - 1

graphPath <- "./04-graphs/"
dataPath <- "./02-data/"
```


```{r data-gathering-functions}

```


```{r operational-functions}
`%notin%` <- Negate(`%in%`)


get_random_row_on_input <- function(combinations_DT) {
  #' @desc when prompted, returns a random row from a given data.table with measures, and visualizes the selection
  #' keeps prompting the user for new input until exited
  #' @param combinations_DT a data.table containing 4 columns with counts, representing a measure
  #' @return a random measure in visualized media as well as written notation
  
  repeat {
    cat("Press Enter to get a random measure or type 'q' to quit:\n")
    input <- readline(prompt = "")
    if (tolower(input) == "exit" | tolower(input) == "q") {
      cat("Exiting function.\n")
      break
    }
    if (input == "") {
      random_row_index <- sample(nrow(combinations_DT), 1)
      selected_row_DT <- combinations_DT[random_row_index]
      
      # Retrieve the notation to find corresponding images
      image_files <- c(notation_lookup[selected_row_DT[, count_1]],
                       notation_lookup[selected_row_DT[, count_2]],
                       notation_lookup[selected_row_DT[, count_3]],
                       notation_lookup[selected_row_DT[, count_4]])
      
      # Load images
      image_paths <- paste0("8th_16_notes/images/", image_files, ".png")
      images <- lapply(image_paths, image_read)
      
      # Add borders to each image for spacing
      images <- lapply(images, function(img) image_border(img, "white", "50x50"))
      
      # Load images and combine them into a composite measure image
      measure_image <- image_montage(do.call(c, images),
                                     tile = "x1",
                                     gravity = "Center",
                                     geometry = "+50+0")
      
      # Resize the final image before displaying
      measure_image <- image_resize(measure_image, "x100")
      print(measure_image)
      
      # Print the combo and full written descriptions
      print(paste("Measure:", combinations_DT[random_row_index, combo]))
      print(paste("Fully written:", combinations_DT[random_row_index, paste(count_1, count_2, count_3, count_4)]))
    }
  }
}
```


```{r visualisation-functions}

```


```{r analysis}
patternsFull <- c("kwart",
                  "8e noot - 8e noot",
                  "16e noot - 8e noot punt",
                  "8e noot punt - 16e noot",
                  "r8 - 16e noot - 16e noot",
                  "16e rust - 16e noot - 16e rust - 16e noot",
                  "16e rust - 16e noot - 16e noot - 16e rust")

patternsNotation <- c("4",
                      "8 - 8",
                      "16 - 8p",
                      "8p - 16",
                      "r8 - 16 - 16",
                      "r16 - 16 - r16 - 16",
                      "r16 - 16 - 16 - r16")

notation_lookup <- setNames(patternsNotation, patternsFull)

combinations <- expand.grid(count_1 = patternsFull, count_2 = patternsFull, 
                            count_3 = patternsFull, count_4 = patternsFull, 
                            stringsAsFactors = FALSE)

combinations <- as.data.table(combinations)
combinations[, combo := paste(notation_lookup[count_1],
                              notation_lookup[count_2],
                              notation_lookup[count_3],
                              notation_lookup[count_4], sep = " | ")]

```


```{r}
get_random_row_on_input(combinations_DT = combinations)
```
